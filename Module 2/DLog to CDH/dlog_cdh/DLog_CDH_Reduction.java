package dlog_cdh;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import cdh.CDH_Challenge;
import dlog.DLog_Challenge;
import dlog.I_DLog_Challenger;
import genericGroups.GroupElement;
import genericGroups.IGroupElement;

/**
 * This is the file you need to implement.
 *
 * Implement the method {@code run} of this class.
 * Do not change the constructor of this class.
 */
public class DLog_CDH_Reduction extends A_DLog_CDH_Reduction<IGroupElement, BigInteger> {

    /**
     * You will need this field.
     */
    private CDH_Challenge<IGroupElement> cdh_challenge;
    /**
     * Save here the group generator of the DLog challenge given to you.
     */
    private IGroupElement g;
    /**
     * Do NOT change or remove this constructor. When your reduction can not provide
     * a working standard constructor, the TestRunner will not be able to test your
     * code and you will get zero points.
     */
    public DLog_CDH_Reduction() {
        // Do not add any code here!
    }

    @Override
    public BigInteger run(I_DLog_Challenger<IGroupElement> challenger) {

        // By the following call you will receive a DLog challenge.
        DLog_Challenge<IGroupElement> challenge = challenger.getChallenge();
        this.g = challenge.generator;

        // trivial case: if g^x == g^0 then x == 0
        if(challenge.x.equals(g.power(BigInteger.ZERO))) {
            return BigInteger.ZERO;
        }

        // consider group Z_p and corresponding generator z
        // => since x belongs to said group, it must hold x == z^k for a certain k
        BigInteger p = g.getGroupOrder();
        BigInteger z = PrimesHelper.getGenerator(p);

        // decompose p as product of prime factors q_i
        int[] q = PrimesHelper.getDecompositionOfPhi(p);

        // by definition g^x^((p-1)/q_i) belongs in subgroup generated by g^z^((p-1)/q_i) for every q_i
        // in particular, there exists k in each ith subgroup such that g^x^((p-1)/q_i) == g^z^(k*((p-1)/q_i))
        int[] k_array = new int[q.length];
        IGroupElement gZ;
        IGroupElement gX;
        boolean found;

        for (int i = 0; i < q.length; i++) {
            found = false;

            for (int k = 0; k < q[i] && !found; k++) {
                BigInteger exp = p.subtract(BigInteger.ONE).divide(BigInteger.valueOf(q[i]));
                gZ = cdh_power(g.power(z), BigInteger.valueOf(k).multiply(exp));
                gX = cdh_power(challenge.x, exp);

                if (gZ.equals(gX)) {
                    k_array[i] = k;
                    found = true;
                }
            }
        }

        // get back k mod p-1 from k mod qi previously obtained
        BigInteger K = CRTHelper.crtCompose(k_array, q);

        // we now have z^K == x
        return z.modPow(K, p);
    }

    @Override
    public CDH_Challenge<IGroupElement> getChallenge() {
        // There is not really a reason to change any of the code of this method.
        return cdh_challenge;
    }

    /**
     * For your own convenience, you should write a cdh method for yourself that,
     * when given group elements g^x and g^y, returns a group element g^(x*y)
     * (where g is the generator from the DLog challenge).
     */
    private IGroupElement cdh(IGroupElement x, IGroupElement y) {
        // Use the run method of your CDH adversary to have it solve CDH-challenges:
        cdh_challenge = new CDH_Challenge<IGroupElement>(g, x, y);
        // You should specify the challenge in the cdh_challenge field of this class.
        // So, the above getChallenge method returns the correct cdh challenge to
        // adversary.
        return adversary.run(this);
    }

    /**
     * For your own convenience, you should write a cdh_power method for yourself
     * that,
     * when given a group element g^x and a number k, returns a group element
     * g^(x^k) (where g is the generator from the DLog challenge).
     */
    private IGroupElement cdh_power(IGroupElement x, BigInteger exponent) {
        // For this method, use your cdh method and think of aritmetic algorithms for
        // fast exponentiation.
        // Use the methods exponent.bitLength() and exponent.testBit(n)!

        IGroupElement y = g;
        
        for (int i = 0; i < exponent.bitLength(); i++) {

            if (exponent.testBit(i))
                y = cdh(y, x);

            x = cdh(x, x);
        }

        return y;
    }
}
